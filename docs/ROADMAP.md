## 1. Language Specifications

### 1.1 Language Goals

### 1.2 Basic Syntax

### 1.3 Formal Gramar (BNF or EBNF)

### 1.4 Data Types and Memory Model

### 1.5 Rules for Visibility, Safety, Mutability

### 1.6 Symbol Table

### 1.7 Type rules & Inference

### 1.8 Scope & Visiblity Validation

### 1.9 Advanced semantic checks

### 1.10 Garbage Collector

### 1.11 Manual Memory Management

### 1.12 Package System

### 1.13 Error Handling

## 2. Lexer

### 2.1 Define tokens (Keywords, Identifiers, Literals, Operators)

### 2.2 Lexical Rules (Regex)

### 2.3 Implement on C++

## 3. Parser

### 3.1 Choose approach

### 3.2 Implement AST

### 3.3 Syntax error handling and recovery

### 3.4 Validation Tests

## 4. Semantic Validation

### 4.1 Symbol table check

### 4.2 Rules and inference check

### 4.3 Scope and Visibility

### 4.4 Advanced semantic (Immutability, Memory Safety, Pointers)

## 5. IR Generation

### 5.1 Define intermediate format (LLVM IR).

### 5.2 Translate AST to IR.

### 5.3 Represent control flow and data flow.

## 6. Optimizations

### 6.1 AST-level optimizations (constant folding, dead code elimination).

### 6.2 IR-level optimizations (copy propagation, loop unrolling).

### 6.3 Efficient memory management (heap, stack, GC).

## 7. Final Code Generation to AMD64

## 8. Runtime & Execution

## 9. Testing & Benchmark

## 10. IDE Integration